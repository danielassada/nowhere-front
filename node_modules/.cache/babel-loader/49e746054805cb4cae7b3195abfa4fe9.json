{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}(); // tslint:disable max-classes-per-file\n\n\nexport var UNOTFOUND = 'UNOTFOUND';\nexport var UACCESS = 'UACCESS';\n/**\n * Base error for all fe2 stuff.\n * This also acts as a polyfill when building with ES5 target.\n */\n\nvar ClientError =\n/** @class */\nfunction (_super) {\n  __extends(ClientError, _super);\n\n  function ClientError(message) {\n    var _this = _super.call(this) || this;\n\n    _this.message = message;\n\n    if (_this.stack) {\n      return _this;\n    }\n\n    if (Error.captureStackTrace) {\n      // chrome etc.\n      Error.captureStackTrace(_this, _this.constructor);\n      return _this;\n    }\n\n    var stack = new Error().stack.split('\\n'); // removes useless stack frame\n\n    stack.splice(1, 1);\n    _this.stack = stack.join('\\n');\n    return _this;\n  }\n\n  ClientError.setProto = function (error) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(error, this.prototype);\n      return;\n    }\n\n    error.__proto__ = this.prototype; // Super emergency fallback\n  };\n\n  return ClientError;\n}(Error);\n\nexport { ClientError };\n/**\n * Emitted by our WebSocket when we get a bad packet; one that is binary,\n * we can't decode, or has a type we don't know about.\n */\n\nvar BadMessageError =\n/** @class */\nfunction (_super) {\n  __extends(BadMessageError, _super);\n\n  function BadMessageError(msg) {\n    var _this = _super.call(this, msg) || this;\n\n    BadMessageError.setProto(_this);\n    return _this;\n  }\n\n  return BadMessageError;\n}(ClientError);\n\nexport { BadMessageError };\n/**\n * Emitted by our WebSocket when we get get a \"reply\" to a method\n * that we don't have a handler for.\n */\n\nvar NoMethodHandlerError =\n/** @class */\nfunction (_super) {\n  __extends(NoMethodHandlerError, _super);\n\n  function NoMethodHandlerError(msg) {\n    var _this = _super.call(this, msg) || this;\n\n    NoMethodHandlerError.setProto(_this);\n    return _this;\n  }\n\n  return NoMethodHandlerError;\n}(ClientError);\n\nexport { NoMethodHandlerError };\n/**\n * Basic \"response\" error message from which others inherit.\n */\n\nvar ResponseError =\n/** @class */\nfunction (_super) {\n  __extends(ResponseError, _super);\n\n  function ResponseError(res) {\n    var _this = _super.call(this, typeof res === 'string' ? res : 'Response error') || this;\n\n    _this.res = res;\n    return _this;\n  }\n\n  return ResponseError;\n}(ClientError);\n\nexport { ResponseError };\n/**\n * Emitted when we try to connect to the Mixer API, but have invalid\n * credentials.\n */\n\nvar AuthenticationFailedError =\n/** @class */\nfunction (_super) {\n  __extends(AuthenticationFailedError, _super);\n\n  function AuthenticationFailedError(res) {\n    var _this = _super.call(this, res) || this;\n\n    AuthenticationFailedError.setProto(_this);\n    return _this;\n  }\n\n  return AuthenticationFailedError;\n}(ResponseError);\n\nexport { AuthenticationFailedError };\n/**\n * Happens when we get a code from the API that we don't expect.\n */\n\nvar UnknownCodeError =\n/** @class */\nfunction (_super) {\n  __extends(UnknownCodeError, _super);\n\n  function UnknownCodeError() {\n    var _this = _super.call(this, 'An unknown error occurred') || this;\n\n    UnknownCodeError.setProto(_this);\n    return _this;\n  }\n\n  return UnknownCodeError;\n}(ResponseError);\n\nexport { UnknownCodeError };\n/**\n * Happens when we attempt to access a point that needs authentication\n * or access that we don't have.\n */\n\nvar NotAuthenticatedError =\n/** @class */\nfunction (_super) {\n  __extends(NotAuthenticatedError, _super);\n\n  function NotAuthenticatedError() {\n    var _this = _super.call(this, 'You do not have permission to view this.') || this;\n\n    NotAuthenticatedError.setProto(_this);\n    return _this;\n  }\n\n  return NotAuthenticatedError;\n}(ResponseError);\n\nexport { NotAuthenticatedError };\n/**\n * A TimeoutError is thrown in call if we don't get a response from the\n * chat server within a certain interval.\n */\n\nvar TimeoutError =\n/** @class */\nfunction (_super) {\n  __extends(TimeoutError, _super);\n\n  function TimeoutError() {\n    var _this = _super.call(this, 'Timeout') || this;\n\n    TimeoutError.setProto(_this);\n    return _this;\n  }\n\n  return TimeoutError;\n}(ClientError);\n\nexport { TimeoutError };","map":null,"metadata":{},"sourceType":"module"}