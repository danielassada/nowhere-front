{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nimport { EventEmitter } from 'events';\nimport { AuthenticationFailedError, BadMessageError, NoMethodHandlerError, TimeoutError, UACCESS, UnknownCodeError, UNOTFOUND } from '../errors';\nimport { Reply } from './Reply'; // The method of the authentication packet to store.\n\nvar authMethod = 'auth';\n/**\n * Return a promise which is rejected with a TimeoutError after the\n * provided delay.\n */\n\nfunction timeout(delay) {\n  return new Socket.Promise(function (_resolve, reject) {\n    setTimeout(function () {\n      return reject(new TimeoutError());\n    }, delay);\n  });\n}\n\nfunction isBrowserWebSocket(socket) {\n  return !socket.ping;\n}\n\nfunction isNodeWebSocket(socket) {\n  return !isBrowserWebSocket(socket);\n}\n/**\n * Wraps a DOM socket with EventEmitter-like syntax.\n */\n\n\nexport function wrapDOM(socket) {\n  function wrapHandler(event, fn) {\n    return function (ev) {\n      if (event === 'message') {\n        fn(ev.data);\n      } else {\n        fn(ev);\n      }\n    };\n  }\n\n  socket.on = function (event, listener) {\n    var wrapped = wrapHandler(event, listener);\n    socket.addEventListener(event, wrapped);\n  };\n\n  socket.once = function (event, listener) {\n    var wrapped = wrapHandler(event, listener);\n    socket.addEventListener(event, function (ev) {\n      wrapped(ev);\n      socket.removeEventListener(event, wrapped);\n    });\n  };\n\n  return socket;\n}\n/**\n * Manages a connect to Mixer's chat servers.\n */\n\nvar Socket =\n/** @class */\nfunction (_super) {\n  __extends(Socket, _super);\n\n  function Socket(wsCtor, addresses, options) {\n    var _this = _super.call(this) || this;\n\n    _this.wsCtor = wsCtor;\n    _this.options = options; // Spool to store events queued when the connection is lost.\n\n    _this._spool = []; // Counter of the current number of reconnect retries, and the number of\n    // retries before we reset our reconnect attempts.\n\n    _this._retries = 0;\n    _this._retryWrap = 7; // max 2 minute retry time;\n\n    _this._optOutEventsArgs = [];\n    _this.options = __assign({\n      pingInterval: 15 * 1000,\n      pingTimeout: 5 * 1000,\n      callTimeout: 20 * 1000,\n      protocolVersion: '1.0',\n      clientId: null\n    }, options); // Which connection we use in our load balancing.\n\n    _this._addressOffset = Math.floor(Math.random() * addresses.length); // List of addresses we can connect to.\n\n    _this._addresses = addresses; // Information for server pings. We ping the server on the interval\n    // (if we don't get any other packets) and consider a connection\n    // dead if it doesn't respond within the timeout.\n\n    _this._pingTimeoutHandle = null; // The status of the socket connection.\n\n    _this.status = Socket.IDLE; // Timeout waiting to reconnect\n\n    _this._reconnectTimeout = null; // Map of call IDs to promises that should be resolved on\n    // method responses.\n\n    _this._replies = {}; // Authentication packet store that we'll resend if we have to reconnect.\n\n    _this._authpacket = null; // Counter for method calls.\n\n    _this._callNo = 0;\n    return _this;\n  } // tslint:disable-next-line: no-unnecessary-override\n\n\n  Socket.prototype.on = function (event, cb) {\n    return _super.prototype.on.call(this, event, cb);\n  };\n  /**\n   * Gets the status of the socket connection.\n   */\n\n\n  Socket.prototype.getStatus = function () {\n    return this.status;\n  };\n  /**\n   * Returns whether the socket is currently connected.\n   */\n\n\n  Socket.prototype.isConnected = function () {\n    return this.status === Socket.CONNECTED;\n  };\n  /**\n   * Retrieves a chat endpoint to connect to. We use round-robin balancing.\n   */\n\n\n  Socket.prototype.getAddress = function () {\n    if (++this._addressOffset >= this._addresses.length) {\n      this._addressOffset = 0;\n    }\n\n    var address = this._addresses[this._addressOffset];\n    address += \"?version=\" + this.options.protocolVersion;\n\n    if (this.options.clientId) {\n      address += \"&Client-ID=\" + this.options.clientId;\n    }\n\n    return address;\n  };\n  /**\n   * Returns how long to wait before attempting to reconnect. This does TCP-style\n   * limited exponential backoff.\n   */\n\n\n  Socket.prototype.getNextReconnectInterval = function () {\n    var power = this._retries++ % this._retryWrap + Math.round(Math.random());\n    return (1 << power) * 500;\n  };\n  /**\n   * handleClose is called when the websocket closes or emits an error. If\n   * we weren't gracefully closed, we'll try to reconnect.\n   */\n\n\n  Socket.prototype.handleClose = function () {\n    clearTimeout(this._pingTimeoutHandle);\n    this._pingTimeoutHandle = null;\n    var socket = this.ws;\n    this.ws = null;\n    this.removeAllListeners('WelcomeEvent');\n\n    if (this.status === Socket.CLOSING) {\n      this.status = Socket.CLOSED;\n      this.emit('closed');\n      return;\n    }\n\n    var interval = this.getNextReconnectInterval();\n    this.status = Socket.CONNECTING;\n    this._reconnectTimeout = setTimeout(this.boot.bind(this), interval);\n    this.emit('reconnecting', {\n      interval: interval,\n      socket: socket\n    });\n  };\n  /**\n   * Sets the socket to send a ping message after an interval. This is\n   * called when a successful ping is received and after data is received\n   * from the socket (there's no need to ping when we know the socket\n   * is still alive).\n   */\n\n\n  Socket.prototype.resetPingTimeout = function () {\n    var _this = this;\n\n    clearTimeout(this._pingTimeoutHandle);\n    this._pingTimeoutHandle = setTimeout(function () {\n      return _this.ping().catch(function () {\n        return undefined;\n      });\n    }, this.options.pingInterval);\n  };\n  /**\n   * Resets the connection timeout handle. This will run the handler\n   * after a short amount of time.\n   */\n\n\n  Socket.prototype.resetConnectionTimeout = function (handler) {\n    clearTimeout(this._pingTimeoutHandle);\n    this._pingTimeoutHandle = setTimeout(handler, this.options.pingTimeout);\n  };\n  /**\n   * Ping runs a ping against the server and returns a promise which is\n   * resolved if the server responds, or rejected on timeout.\n   */\n\n\n  Socket.prototype.ping = function () {\n    var _this = this;\n\n    var ws = this.ws;\n    clearTimeout(this._pingTimeoutHandle);\n\n    if (!this.isConnected()) {\n      return new Socket.Promise(function (_resolve, reject) {\n        reject(new TimeoutError());\n      });\n    }\n\n    var promise;\n\n    if (isNodeWebSocket(ws)) {\n      // Node's ws module has a ping function we can use rather than\n      // sending a message. More lightweight, less noisy.\n      promise = Socket.Promise.race([timeout(this.options.pingTimeout), new Socket.Promise(function (resolve) {\n        return ws.once('pong', resolve);\n      })]);\n      ws.ping();\n    } else {\n      // Otherwise we'll resort to sending a ping message over the socket.\n      promise = this.call('ping', [], {\n        timeout: this.options.pingTimeout\n      });\n    }\n\n    return promise.then(this.resetPingTimeout.bind(this)).catch(function (err) {\n      if (!(err instanceof TimeoutError)) {\n        throw err;\n      } // If we haven't noticed the socket is dead since we started trying\n      // to ping, manually emit an error. This'll cause it to close.\n\n\n      if (_this.ws === ws) {\n        _this.emit('error', err);\n\n        ws.close(); // trigger a close immediately -- some browsers are slow about this,\n        // leading to a delay before we try reconnecting.\n\n        _this.handleClose();\n      }\n\n      throw err;\n    });\n  };\n  /**\n   * Starts a socket client. Attaches events and tries to connect to a\n   * chat server.\n   * @fires Socket#connected\n   * @fires Socket#closed\n   * @fires Socket#error\n   */\n\n\n  Socket.prototype.boot = function () {\n    var _this = this;\n\n    var ws = this.ws = new this.wsCtor(this.getAddress());\n\n    if (isBrowserWebSocket(ws)) {\n      wrapDOM(ws);\n    }\n\n    var whilstSameSocket = function whilstSameSocket(fn) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        if (_this.ws === ws) {\n          fn.apply(_this, args);\n        }\n      };\n    };\n\n    this.status = Socket.CONNECTING; // If the connection doesn't open fast enough\n\n    this.resetConnectionTimeout(function () {\n      ws.close();\n    }); // Websocket connection has been established.\n\n    ws.on('open', whilstSameSocket(function () {\n      // If we don't get a WelcomeEvent, kill the connection\n      _this.resetConnectionTimeout(function () {\n        ws.close();\n      });\n    })); // Chat server has acknowledged our connection\n\n    this.once('WelcomeEvent', function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      _this.resetPingTimeout();\n\n      _this.unspool.apply(_this, args);\n    }); // We got an incoming data packet.\n\n    ws.on('message', whilstSameSocket(function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      _this.resetPingTimeout();\n\n      _this.parsePacket.apply(_this, args);\n    })); // Websocket connection closed\n\n    ws.on('close', whilstSameSocket(function () {\n      _this.handleClose();\n    })); // Websocket hit an error and is about to close.\n\n    ws.on('error', whilstSameSocket(function (err) {\n      _this.emit('error', err);\n\n      ws.close();\n    }));\n    return this;\n  };\n  /**\n   * Should be called on reconnection. Authenticates and sends follow-up\n   * packets if we have any. After we get re-established with auth\n   * we'll formally say this socket is connected. This is to prevent\n   * race conditions where packets could get send before authentication\n   * is reestablished.\n   */\n\n\n  Socket.prototype.unspool = function () {\n    var _this = this; // Helper function that's called when we're fully reestablished and\n    // ready to take direct calls again.\n\n\n    var bang = function bang() {\n      // Send any spooled events that we have.\n      for (var i = 0; i < _this._spool.length; i++) {\n        // tslint:disable-next-line no-floating-promises\n        _this.send(_this._spool[i].data, {\n          force: true\n        }).catch(function (err) {\n          _this.emit('error', err);\n        });\n\n        _this._spool[i].resolve();\n      }\n\n      _this._spool = []; // Finally, tell the world we're connected.\n\n      _this._retries = 0;\n      _this.status = Socket.CONNECTED;\n\n      _this.emit('connected');\n    };\n\n    var promise = Promise.resolve();\n\n    if (this._optOutEventsArgs.length) {\n      promise = promise.then(function () {\n        return _this.call('optOutEvents', _this._optOutEventsArgs, {\n          force: true\n        });\n      }).catch(function () {\n        return _this.emit('error', new UnknownCodeError());\n      }).then(function () {\n        return _this.emit('optOutResult');\n      });\n    } // If we already authed, it means we're reconnecting and should\n    // establish authentication again.\n\n\n    if (this._authpacket) {\n      // tslint:disable-next-line no-floating-promises\n      promise = promise.then(function () {\n        return _this.call(authMethod, _this._authpacket, {\n          force: true\n        });\n      }).then(function (result) {\n        return _this.emit('authresult', result);\n      });\n    }\n\n    promise.then(bang).catch(function (e) {\n      var message = 'Authentication Failed, please check your credentials.';\n\n      if (e.message === UNOTFOUND) {\n        message = 'Authentication Failed: User not found. Please check our guide at: https://aka.ms/unotfound';\n      }\n\n      if (e.message === UACCESS) {\n        message = 'Authentication Failed: Channel is in test mode. The client user does not have access during test mode.';\n      }\n\n      _this.emit('error', new AuthenticationFailedError(message));\n\n      _this.close();\n    });\n  };\n  /**\n   * Parses an incoming packet from the websocket.\n   * @fires Socket#error\n   * @fires Socket#packet\n   */\n\n\n  Socket.prototype.parsePacket = function (data, flags) {\n    if (flags && flags.binary) {\n      // We can't handle binary packets. Why the fudge are we here?\n      this.emit('error', new BadMessageError('Cannot parse binary packets. Wat.'));\n      return;\n    } // Unpack the packet data.\n\n\n    var packet;\n\n    try {\n      packet = JSON.parse(data);\n    } catch (e) {\n      this.emit('error', new BadMessageError('Unable to parse packet as json'));\n      return;\n    }\n\n    this.emit('packet', packet);\n\n    switch (packet.type) {\n      case 'reply':\n        // Try to look up the packet reply handler, and call it if we can.\n        var reply = this._replies[packet.id];\n\n        if (reply !== undefined) {\n          reply.handle(packet);\n          delete this._replies[packet.id];\n        } else {\n          // Otherwise emit an error. This might happen occasionally,\n          // but failing silently is lame.\n          this.emit('error', new NoMethodHandlerError('No handler for reply ID.'));\n        }\n\n        break;\n\n      case 'event':\n        // Just emit events out on this emitter.\n        this.emit(packet.event, packet.data);\n        break;\n\n      default:\n        this.emit('error', new BadMessageError('Unknown packet type ' + packet.type));\n    }\n  };\n  /**\n   * Sends raw packet data to the server. It may not send immediately;\n   * if we aren't connected, it'll just be spooled up.\n   *\n   * @fires Socket#sent\n   * @fires Socket#spooled\n   */\n\n\n  Socket.prototype.send = function ( // tslint:disable-next-line no-banned-terms\n  data, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (this.isConnected() || options.force) {\n      this.ws.send(JSON.stringify(data));\n      this.emit('sent', data);\n      return Socket.Promise.resolve();\n    } else if (data.method !== authMethod) {\n      return new Socket.Promise(function (resolve) {\n        _this._spool.push({\n          data: data,\n          resolve: resolve\n        });\n\n        _this.emit('spooled', data);\n      });\n    }\n\n    return Socket.Promise.resolve();\n  };\n  /**\n   * auth sends a packet over the socket to authenticate with a chat server\n   * and join a specified channel. If you wish to join anonymously, user\n   * and authkey can be omitted.\n   */\n\n\n  Socket.prototype.auth = function (id, user, authkey, accessKey) {\n    var _this = this;\n\n    this._authpacket = [id, user, authkey, accessKey]; // Two cases here: if we're already connected, with send the auth\n    // packet immediately. Otherwise we wait for a `connected` event,\n    // which won't be sent until after we re-authenticate.\n\n    if (this.isConnected()) {\n      return this.call('auth', [id, user, authkey, accessKey]);\n    }\n\n    return new Socket.Promise(function (resolve) {\n      return _this.once('authresult', resolve);\n    });\n  };\n  /**\n   * optOutEvents sends a packet over the socket to opt out from receiving events\n   * from a chat server. Pass in Events to be opted out from as args\n   */\n\n\n  Socket.prototype.optOutEvents = function (args) {\n    var _this = this;\n\n    if (args.length === 0) {\n      return Promise.resolve();\n    }\n\n    this._optOutEventsArgs = args;\n\n    if (this.isConnected()) {\n      return this.call('optOutEvents', args);\n    }\n\n    return new Socket.Promise(function (resolve) {\n      return _this.once('optOutResult', resolve);\n    });\n  };\n\n  Socket.prototype.call = function (method, args, options) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    if (options === void 0) {\n      options = {};\n    } // Send out the data\n\n\n    var id = this._callNo++; // This is created before we call and wait on .send purely for ease\n    // of use in tests, so that we can mock an incoming packet synchronously.\n\n    var replyPromise = new Socket.Promise(function (resolve, reject) {\n      _this._replies[id] = new Reply(resolve, reject);\n    });\n    return this.send({\n      type: 'method',\n      method: method,\n      arguments: args,\n      id: id\n    }, options).then(function () {\n      // Then create and return a promise that's resolved when we get\n      // a reply, if we expect one to be given.\n      if (options.noReply) {\n        return undefined;\n      }\n\n      return Socket.Promise.race([timeout(options.timeout || _this.options.callTimeout), replyPromise]);\n    }).catch(function (err) {\n      if (err instanceof TimeoutError) {\n        delete _this._replies[id];\n      }\n\n      throw err;\n    });\n  };\n  /**\n   * Closes the websocket gracefully.\n   */\n\n\n  Socket.prototype.close = function () {\n    if (this.ws) {\n      this.ws.close();\n      this.status = Socket.CLOSING;\n    } else {\n      clearTimeout(this._reconnectTimeout);\n      this.status = Socket.CLOSED;\n    }\n  };\n  /**\n   * We've not tried connecting yet\n   */\n\n\n  Socket.IDLE = 0;\n  /**\n   * We successfully connected\n   */\n\n  Socket.CONNECTED = 1;\n  /**\n   * The socket was is closing gracefully.\n   */\n\n  Socket.CLOSING = 2;\n  /**\n   * The socket was closed gracefully.\n   */\n\n  Socket.CLOSED = 3;\n  /**\n   * We're currently trying to connect.\n   */\n\n  Socket.CONNECTING = 4; // tslint:disable-next-line variable-name\n\n  Socket.Promise = Promise;\n  return Socket;\n}(EventEmitter);\n\nexport { Socket };","map":null,"metadata":{},"sourceType":"module"}