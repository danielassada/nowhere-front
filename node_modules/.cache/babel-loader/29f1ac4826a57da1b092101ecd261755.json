{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nimport { AuthenticationFailedError } from '../errors';\nimport { Provider } from './Provider';\n/**\n * Provider for oauth-based authentication.\n */\n\nvar OAuthProvider =\n/** @class */\nfunction (_super) {\n  __extends(OAuthProvider, _super);\n\n  function OAuthProvider(client, options) {\n    var _this = _super.call(this, client) || this;\n\n    _this.details = {\n      client_id: options.clientId,\n      client_secret: options.secret\n    };\n\n    _this.setTokens(options.tokens);\n\n    return _this;\n  }\n  /**\n   * Returns if the client is currently authenticated: they must\n   * have a non-expired key pair.\n   */\n\n\n  OAuthProvider.prototype.isAuthenticated = function () {\n    return this.tokens.access !== undefined && this.tokens.expires.getTime() > Date.now();\n  };\n  /**\n   * Returns a redirect to the webpage to get authentication.\n   */\n\n\n  OAuthProvider.prototype.getRedirect = function (redirect, permissions) {\n    var params = {\n      redirect_uri: redirect,\n      response_type: 'code',\n      scope: typeof permissions === 'string' ? permissions : permissions.join(' '),\n      client_id: this.details.client_id\n    };\n    return this.client.buildAddress(this.client.urls.public, '/oauth/authorize', params);\n  };\n  /**\n   * Returns the access token, if any, or undefined.\n   */\n\n\n  OAuthProvider.prototype.accessToken = function () {\n    return this.tokens.access;\n  };\n  /**\n   * Returns the refresh token, if any, or undefined.\n   */\n\n\n  OAuthProvider.prototype.refreshToken = function () {\n    return this.tokens.refresh;\n  };\n  /**\n   * Returns the date that the current tokens expire. You must refresh\n   * before then, or reauthenticate.\n   */\n\n\n  OAuthProvider.prototype.expires = function () {\n    return this.tokens.expires;\n  };\n  /**\n   * Returns the set of tokens. These can be saved and used to\n   * reload the provider later using OAuthProvider.fromTokens.\n   */\n\n\n  OAuthProvider.prototype.getTokens = function () {\n    return this.tokens;\n  };\n  /**\n   * Sets the tokens for the oauth provider.\n   */\n\n\n  OAuthProvider.prototype.setTokens = function (tokens) {\n    if (!tokens) {\n      this.tokens = {};\n    } else {\n      this.tokens = {\n        access: tokens.access,\n        refresh: tokens.refresh,\n        expires: new Date(tokens.expires)\n      };\n    }\n\n    return this;\n  };\n  /**\n   * Unpacks data from a token response.\n   */\n\n\n  OAuthProvider.prototype.unpackResponse = function (res) {\n    if (res.statusCode !== 200) {\n      throw new AuthenticationFailedError(res);\n    }\n\n    this.tokens = {\n      access: res.body.access_token,\n      refresh: res.body.refresh_token,\n      expires: new Date(Date.now() + res.body.expires_in * 1000)\n    };\n  };\n  /**\n   * Attempts to authenticate based on a query string, gotten from\n   * redirecting back from the authorization url (see .getRedirect).\n   *\n   * Returns a promise which is rejected if there was an error\n   * in obtaining authentication.\n   */\n\n\n  OAuthProvider.prototype.attempt = function (redirect, qs) {\n    var _this = this;\n\n    if (qs.error) {\n      return Promise.reject(new AuthenticationFailedError(qs.error_description || 'Error from oauth: ' + qs.error));\n    }\n\n    if (!qs.code) {\n      // XXX: https://github.com/prettier/prettier/issues/3804\n      return Promise.reject(new AuthenticationFailedError('No error was given, but a code was not present in the query string. ' + \"Make sure you're using the oauth client correctly.\")); // silly devlopers\n    }\n\n    return this.client.request('post', '/oauth/token', {\n      form: __assign({\n        grant_type: 'authorization_code',\n        code: qs.code,\n        redirect_uri: redirect\n      }, this.details)\n    }).then(function (res) {\n      return _this.unpackResponse(res);\n    });\n  };\n  /**\n   * Refreshes the authentication tokens, bumping the expires time.\n   */\n\n\n  OAuthProvider.prototype.refresh = function () {\n    var _this = this;\n\n    if (!this.tokens.refresh) {\n      return Promise.reject(new AuthenticationFailedError('Attempted to refresh without a refresh token present.'));\n    }\n\n    return this.client.request('post', '/oauth/token', {\n      form: __assign({\n        grant_type: 'refresh_token',\n        refresh_token: this.tokens.refresh\n      }, this.details)\n    }).then(function (res) {\n      return _this.unpackResponse(res);\n    });\n  };\n  /**\n   * Returns info to add to the client's request.\n   */\n\n\n  OAuthProvider.prototype.getRequest = function () {\n    var headers = {\n      'Client-ID': this.details.client_id\n    };\n\n    if (this.isAuthenticated()) {\n      headers['Authorization'] = \"Bearer \" + this.tokens.access;\n    }\n\n    return {\n      headers: headers\n    };\n  };\n\n  OAuthProvider.prototype.getClientId = function () {\n    return this.details.client_id;\n  };\n\n  return OAuthProvider;\n}(Provider);\n\nexport { OAuthProvider };","map":null,"metadata":{},"sourceType":"module"}